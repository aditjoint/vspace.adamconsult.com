<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ADAM Signage Player</title>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<style>
body {display:grid;grid-template-columns:repeat(9,1fr);grid-gap:4px;margin:0;background:#000}
.tile-container {position:relative;padding-top:56.25%;overflow:hidden}
.tile-container iframe,.tile-container video {position:absolute;top:0;left:0;width:100%;height:100%}
.fullscreen {position:fixed!important;top:0;left:0;width:100%!important;height:100%!important;z-index:9999}
</style>
</head>
<body>
<script>
const channel = new BroadcastChannel('signage-control');
const tilesData = [];
const tileElements = [];
let playlistData = {};

// Create 9x9 grid
for(let i=0;i<81;i++){
  const container = document.createElement('div');
  container.className = 'tile-container';
  document.body.appendChild(container);
  tileElements.push(container);
  
  // Assign zones/languages
  const zone = i < 27 ? 'Lobby' : (i < 54 ? 'Shop' : 'Conference');
  const language = i%2===0?'en':'hi';
  tilesData.push({zone,language,currentItemIndex:0});
}

// Load playlist configuration
async function loadPlaylist(){
  try{
    const res = await fetch('playlists.json');
    playlistData = await res.json();
  }catch(e){console.error('Failed to load playlist',e);}
}
loadPlaylist();

// Get current playlist based on time and zone
function getCurrentPlaylist(tile){
  const zoneData = playlistData[tile.zone];
  if(!zoneData) return null;
  const langData = zoneData[tile.language] || [];
  const now = new Date();
  const curMin = now.getHours()*60 + now.getMinutes();
  for(let pl of langData){
    const [sh,sm] = pl.start.split(':').map(Number);
    const [eh,em] = pl.end.split(':').map(Number);
    if(curMin >= sh*60+sm && curMin < eh*60+em) return pl;
  }
  return null;
}

// Play content with proper cleanup
function playTile(tileEl,playlist,index=0){
  if(!playlist || !playlist.items || playlist.items.length===0) return;
  const item = playlist.items[index];
  if(!item) return;
  
  // Cleanup previous content
  tileEl.innerHTML = '';
  if(tileEl.hls) {tileEl.hls.destroy();tileEl.hls=null;}
  if(tileEl.iframe) {tileEl.iframe.remove();tileEl.iframe=null;}
  if(tileEl.img) {tileEl.img.remove();tileEl.img=null;}
  
  // Create new content
  if(item.type==='hls'){
    const video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.playsInline = true;
    tileEl.appendChild(video);
    if(Hls.isSupported()){
      const hls = new Hls();
      hls.loadSource(item.url);
      hls.attachMedia(video);
      tileEl.hls = hls;
    } else {
      video.src = item.url;
    }
  } else if(item.type==='youtube'){
    const iframe = document.createElement('iframe');
    iframe.src = item.url.includes('embed') ? item.url : `https://www.youtube.com/embed/${item.url.split('v=')[1]}?autoplay=1&mute=1`;
    iframe.allow = 'autoplay';
    tileEl.appendChild(iframe);
    tileEl.iframe = iframe;
  } else if(item.type==='image'){
    const img = document.createElement('img');
    img.src = item.url;
    tileEl.appendChild(img);
    tileEl.img = img;
  }
  
  // Setup next item loop
  const duration = (item.duration || 30) * 1000;
  tileEl.currentItemIndex = index;
  setTimeout(()=>{
    const nextIndex = (index+1) % playlist.items.length;
    playTile(tileEl,playlist,nextIndex);
  },duration);
}

// Update all tiles
function updateTiles(){
  tilesData.forEach((tile,i)=>{
    const playlist = getCurrentPlaylist(tile);
    if(playlist){
      const tileEl = tileElements[i];
      playTile(tileEl,playlist,tile.currentItemIndex);
    }
  });
}
setInterval(updateTiles,10000);
updateTiles();

// Handle broadcast commands
channel.onmessage = e=>{
  const data = e.data;
  if(data.action==='play' && data.index!==undefined){
    const tileEl = tileElements[data.index];
    const item = {url:data.url,type:'video'};
    playTile(tileEl,{items:[item]},0);
  } else if(data.action==='broadcast'){
    tileElements.forEach(el=>playTile(el,{items:[{url:data.url,type:'video'}]},0));
  } else if(data.action==='clear'){
    tileElements.forEach(el=>el.innerHTML='');
  } else if(data.action==='fullscreen' && data.index!==undefined){
    const el = tileElements[data.index];
    if(!el.classList.contains('fullscreen')){
      el.classList.add('fullscreen');
    } else {
      el.classList.remove('fullscreen');
    }
  }
};
</script>
</body>
</html>
