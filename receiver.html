<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ADAM Signage Receiver</title>
<script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<style>
body, html { 
  margin: 0; 
  padding: 0; 
  width: 100%; 
  height: 100%; 
  overflow: hidden; 
  background: #000; 
}
.grid-container { 
  display: grid; 
  grid-template-columns: repeat(9, 1fr); 
  grid-template-rows: repeat(9, 1fr); 
  width: 100%; 
  height: 100%; 
  gap: 2px; 
}
.grid-item { 
  background: #111; 
  position: relative; 
  overflow: hidden; 
}
.grid-item video, 
.grid-item img, 
.grid-item iframe { 
  width: 100%; 
  height: 100%; 
  object-fit: contain; 
}
.grid-item::after {
  content: attr(data-index);
  position: absolute;
  bottom: 4px;
  right: 4px;
  background: rgba(0,0,0,0.8);
  color: #0d6efd;
  font-size: 12px;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 3px;
  font-family: monospace;
}
#fullscreen { 
  position: fixed; 
  top: 0; 
  left: 0; 
  width: 100%; 
  height: 100%; 
  background: #000; 
  z-index: 1000; 
  display: none; 
}
#fullscreen video,
#fullscreen img,
#fullscreen iframe {
  width: 100%;
  height: 100%;
  object-fit: contain;
}
/* Clock overlay for scheduled content */
.clock-overlay {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 5px 10px;
  border-radius: 5px;
  font-family: monospace;
  font-size: 12px;
  z-index: 2000;
}
/* Schedule indicator */
.schedule-indicator {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(13,110,253,0.8);
  color: white;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 12px;
  z-index: 2000;
}
</style>
</head>
<body>
<div class="grid-container" id="grid"></div>
<div id="fullscreen"></div>
<div class="clock-overlay" id="clock"></div>
<div class="schedule-indicator" id="scheduleInfo" style="display:none;"></div>

<script>
const context = cast.framework.CastReceiverContext.getInstance();
const playerManager = context.getPlayerManager();
const grid = document.getElementById('grid');
const tiles = [];
const fullscreen = document.getElementById('fullscreen');
const clock = document.getElementById('clock');
const scheduleInfo = document.getElementById('scheduleInfo');

// Create 9x9 grid
for (let i = 0; i < 81; i++) {
  const tile = document.createElement('div');
  tile.className = 'grid-item';
  tile.id = `tile-${i}`;
  tile.setAttribute('data-index', i + 1);
  grid.appendChild(tile);
  tiles.push(tile);
}

// Clock display
function updateClock() {
  const now = new Date();
  clock.textContent = now.toLocaleTimeString();
  setTimeout(updateClock, 1000);
}
updateClock();

// Current schedule
let currentSchedule = null;
let scheduleTimer = null;

// Handle load requests
playerManager.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, request => {
  console.log('Load request:', request);
  
  // Clear any existing schedule
  if (scheduleTimer) {
    clearTimeout(scheduleTimer);
    scheduleTimer = null;
  }
  
  // Hide schedule info
  scheduleInfo.style.display = 'none';
  currentSchedule = null;
  
  // Handle different content types
  if (request.customData && request.customData.gridMode === 'pip9x9') {
    // 9x9 Grid mode
    tiles.forEach(tile => tile.innerHTML = '');
    
    if (request.customData.urls && Array.isArray(request.customData.urls)) {
      request.customData.urls.forEach((url, index) => {
        if (index < 81) {
          loadContent(tiles[index], url);
        }
      });
    }
    
  } else if (request.customData && request.customData.scheduleId) {
    // Scheduled content mode
    handleScheduledContent(request.customData);
    
  } else if (request.media && request.media.contentId) {
    // Single content mode
    tiles.forEach(tile => tile.innerHTML = '');
    fullscreen.style.display = 'block';
    loadContent(fullscreen, request.media.contentId);
  }
  
  return request;
});

// Handle stop requests
playerManager.setMessageInterceptor(cast.framework.messages.MessageType.STOP, request => {
  tiles.forEach(tile => tile.innerHTML = '');
  fullscreen.style.display = 'none';
  fullscreen.innerHTML = '';
  
  // Clear schedule
  if (scheduleTimer) {
    clearTimeout(scheduleTimer);
    scheduleTimer = null;
  }
  scheduleInfo.style.display = 'none';
  currentSchedule = null;
  
  return request;
});

// Handle scheduled content
function handleScheduledContent(scheduleData) {
  // Clear current display
  tiles.forEach(tile => tile.innerHTML = '');
  fullscreen.style.display = 'none';
  
  // Display schedule info
  scheduleInfo.textContent = `Schedule: ${scheduleData.name}`;
  scheduleInfo.style.display = 'block';
  
  // Load content based on schedule
  if (scheduleData.gridMapping) {
    scheduleData.gridMapping.forEach(item => {
      if (item.tile < tiles.length && item.contentUrl) {
        loadContent(tiles[item.tile], item.contentUrl);
      }
    });
  }
  
  // Set up schedule end
  if (scheduleData.endTime) {
    const end = new Date(scheduleData.endTime);
    const now = new Date();
    const delay = end.getTime() - now.getTime();
    
    if (delay > 0) {
      scheduleTimer = setTimeout(() => {
        // Clear schedule
        tiles.forEach(tile => tile.innerHTML = '');
        scheduleInfo.style.display = 'none';
        currentSchedule = null;
      }, delay);
    }
  }
  
  currentSchedule = scheduleData;
}

// Load content into container
function loadContent(container, url) {
  container.innerHTML = '';
  
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    let videoId = '';
    if (url.includes('v=')) {
      videoId = url.split('v=')[1].split('&')[0];
    } else if (url.includes('youtu.be/')) {
      videoId = url.split('youtu.be/')[1].split('?')[0];
    }
    
    if (videoId) {
      const iframe = document.createElement('iframe');
      iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&mute=1&controls=0&loop=1`;
      iframe.allow = 'autoplay; encrypted-media';
      iframe.frameBorder = '0';
      container.appendChild(iframe);
    }
  } else if (url.match(/\.(jpeg|jpg|gif|png|bmp|webp)$/i)) {
    const img = document.createElement('img');
    img.src = url;
    img.onload = () => console.log('Image loaded:', url);
    img.onerror = () => console.error('Image failed to load:', url);
    container.appendChild(img);
  } else if (url.match(/\.(mp4|webm|ogg)$/i)) {
    const video = document.createElement('video');
    video.src = url;
    video.autoplay = true;
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    video.onloadedmetadata = () => console.log('Video loaded:', url);
    video.onerror = () => console.error('Video failed to load:', url);
    container.appendChild(video);
  } else if (url.includes('.m3u8')) {
    const video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.loop = true;
    video.playsInline = true;
    container.appendChild(video);
    
    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(url);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        console.log('HLS stream loaded:', url);
      });
      hls.on(Hls.Events.ERROR, (event, data) => {
        console.error('HLS error:', data);
      });
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = url;
      video.addEventListener('loadedmetadata', () => {
        console.log('Native HLS loaded:', url);
      });
    }
  } else {
    const iframe = document.createElement('iframe');
    iframe.src = url;
    iframe.allow = 'autoplay; fullscreen';
    iframe.frameBorder = '0';
    iframe.style.border = 'none';
    iframe.onload = () => console.log('Iframe loaded:', url);
    iframe.onerror = () => console.error('Iframe failed to load:', url);
    container.appendChild(iframe);
  }
}

// Handle pause/resume
playerManager.setMessageInterceptor(cast.framework.messages.MessageType.PAUSE, request => {
  // Pause all videos
  document.querySelectorAll('video').forEach(video => {
    if (!video.paused) {
      video.pause();
    }
  });
  return request;
});

playerManager.setMessageInterceptor(cast.framework.messages.MessageType.PLAY, request => {
  // Resume all videos
  document.querySelectorAll('video').forEach(video => {
    if (video.paused) {
      video.play().catch(e => console.error('Play error:', e));
    }
  });
  return request;
});

// Start the receiver
context.start();
</script>
</body>
</html>

